Orientações Trabalho N2 - Teste de Software
1) Objetivos de Aprendizagem
● Aplicar ciclo de vida de testes (setup/teardown, fixtures) em Java (JUnit 5) e/ou
Python (pytest).
● Praticar TDD em uma funcionalidade pequena porém não‑trivial.
● Escrever testes de exceções e parametrizados.
● Implementar stubs e mocks para dobrar dependências (e‑mail, pagamento,
repositório, API).
● Desenvolver testes de integração com simulações (sem acessar serviços reais).
● Medir cobertura (linhas e ramos) e criar pipeline de CI básico.
Entrega pode ser em Java, Python, ou ambos. Use o stack de sua
preferência, mas mantenha a mesma estrutura e artefatos abaixo.
2) Contexto do Trabalho (escolha 1 dos cenários -
faremos juntos na Sala de Aula)
Cenário A — Faturamento & Pagamentos
● Entidades: Cliente, Fatura, ItemFatura (qtd, preço), Pagamento.
● Regras: imposto simples (%), desconto por cupom, cálculo de total, geração de
e‑mail de cobrança.
● Dependências dobráveis: EmailService (stub), GatewayPagamento (mock).
Cenário B — Catálogo & Carrinho
● Entidades: Produto, Estoque, Carrinho.
● Regras: reserva de estoque, promoção progressiva, cupom, frete.
● Dependências dobráveis: EstoqueRepository (stub), FreteAPI (mock).
Cenário C — Biblioteca
● Entidades: Livro, Usuario, Emprestimo.
● Regras: multa por atraso, limite por usuário, notificação por e‑mail.
● Dependências dobráveis: Relogio (stub controlado), EmailService (mock/stub).
Observação: Evite I/O real (banco, rede). Use dobles. Prove integração via
repositórios em memória.
3) Itens Obrigatórios
1. Ciclo de vida de testes (fixtures):
○ Java: @BeforeEach, @AfterEach, @TempDir quando útil.
○ Python: @pytest.fixture (escopo function), tmp_path.
2. TDD de uma funcionalidade (ex.: cálculo de total com cupons; regra de multa; regra
de frete). Inclua histórico de commits: vermelho → verde → refatorar.
3. Testes de Exceção: casos inválidos (qtd ≤ 0, cupom expirado, pagamento recusado
etc.).
4. Parametrizados:
○ Java: @ParameterizedTest com @CsvSource ou @MethodSource.
○ Python: @pytest.mark.parametrize.
5. Stubs & Mocks:
○ Stub de e‑mail (sem enviar de fato).
○ Mock de gateway de pagamento (simular aprovado/negado, latência).
6. Integração com simulações:
○ Repositório em memória (ex.: InMemoryFaturaRepository).
○ Teste de um fluxo completo ponta‑a‑ponta sem serviços reais.
7. Performance:
○ Java: assertTimeout/assertTimeoutPreemptively para operação
crítica.
○ Python: medir tempo com time.perf_counter() em um teste marcado
como slow (sem libs externas).
8. Cobertura:
○ Java: JaCoCo (relatório XML/HTML).
○ Python: coverage.py (HTML + XML).
○ Meta sugerida: ≥ 80% linhas e ≥ 70% branches no módulo de regras de
negócio.
9. CI (GitHub Actions) executando testes + relatório de cobertura (salvar artefatos).
10. README com: instruções de execução, decisões de design, mapa de testes, limites
conhecidos.
4) Estrutura de Repositório (sugestão)
trabalho-aula06/
java/ (opcional)
pom.xml
src/
main/java/... # código de produção
test/java/... # testes JUnit 5
python/ (opcional)
pyproject.toml or requirements.txt
src/...
tests/...
.github/workflows/ci.yml
README.md
5) Guia de Implementação — Java (JUnit 5)
Dependências mínimas (Maven)
<dependencies>
<dependency>
<groupId>org.junit.jupiter</groupId>
<artifactId>junit-jupiter</artifactId>
<version>5.10.2</version>
<scope>test</scope>
</dependency>
<dependency>
<groupId>org.mockito</groupId>
<artifactId>mockito-junit-jupiter</artifactId>
<version>5.11.0</version>
<scope>test</scope>
</dependency>
</dependencies>
<build>
<plugins>
<plugin>
<groupId>org.jacoco</groupId>
<artifactId>jacoco-maven-plugin</artifactId>
<version>0.8.11</version>
<executions>
<execution>
<goals><goal>prepare-agent</goal></goals>
</execution>
<execution>
<id>report</id>
<phase>test</phase>
<goals><goal>report</goal></goals>
</execution>
</executions>
</plugin>
</plugins>
</build>
Esqueleto de teste
@ExtendWith(MockitoExtension.class)
class FaturaServiceTest {
@Mock EmailService emailService; // mock
@Mock GatewayPagamento gateway; // mock
InMemoryFaturaRepository repo; // stub/repo em memória
FaturaService service;
@BeforeEach
void setUp() {
repo = new InMemoryFaturaRepository();
service = new FaturaService(repo, emailService, gateway);
}
@ParameterizedTest
@CsvSource({"2, 10.0, 0, 20.0", "3, 5.0, 10, 13.5"})
void calculaTotal_comDesconto(int qtd, double preco, int descontoPct, double esperado) {
double total = service.calcularTotal(qtd, preco, descontoPct);
assertEquals(esperado, total, 0.0001);
}
@Test
void lancaExcecao_quandoQuantidadeInvalida() {
assertThrows(IllegalArgumentException.class, () -> service.calcularTotal(0, 10.0, 0));
}
@Test
void enviaEmailAposPagamentoAprovado() {
when(gateway.pagar(any())).thenReturn(RespostaPagamento.aprovado("123"));
service.fecharFatura("cli-1", List.of(new Item(2, 10.0)));
verify(emailService).enviarCobranca(any());
}
@Test
void deveCompletarFluxoEmMenosDe200ms() {
assertTimeout(Duration.ofMillis(200), () -> {
service.fecharFatura("cli-1", List.of(new Item(3, 5.0)));
});
}
}
6) Guia de Implementação — Python (pytest)
Dependências mínimas
pytest
coverage
Esqueleto de teste
import time
import pytest
from src.fatura import FaturaService, InMemoryFaturaRepository
class StubEmailService:
def __init__(self):
self.enviados = []
def enviar_cobranca(self, msg):
self.enviados.append(msg)
class MockGatewayPagamento:
def __init__(self, aprovar=True):
self.aprovar = aprovar
def pagar(self, dados):
return {"status": "aprovado" if self.aprovar else "negado", "id": "123"}
@pytest.fixture
def service():
repo = InMemoryFaturaRepository()
email = StubEmailService()
gateway = MockGatewayPagamento(aprovar=True)
return FaturaService(repo, email, gateway)
@pytest.mark.parametrize(
"qtd, preco, desconto, esperado",
[(2, 10.0, 0, 20.0), (3, 5.0, 10, 13.5)]
)
def test_calcula_total(service, qtd, preco, desconto, esperado):
assert service.calcular_total(qtd, preco, desconto) == pytest.approx(esperado)
def test_excecao_qtd_invalida(service):
with pytest.raises(ValueError):
service.calcular_total(0, 10.0, 0)
def test_envia_email_apos_pagamento_aprovado(service):
service.fechar_fatura("cli-1", [(2, 10.0)])
assert service.email.enviados # pelo menos 1 mensagem
@pytest.mark.slow
def test_deve_ser_rapido(service):
t0 = time.perf_counter()
service.fechar_fatura("cli-1", [(3, 5.0)])
assert (time.perf_counter() - t0) < 0.2
7) Teste de Integração (ponta‑a‑ponta)
● Simule fluxo: criar fatura → aplicar cupom → pagar via GatewayPagamento mock
→ persistir no repo em memória → enviar e‑mail (stub) → validar estados finais.
● Valide efeitos colaterais (itens persistidos, número de e‑mails, status do pagamento).
8) Pipeline de CI (GitHub Actions — exemplo
simplificado)
name: ci
on: [push, pull_request]
jobs:
python:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v4
- uses: actions/setup-python@v5
with: { python-version: '3.11' }
- run: pip install -r python/requirements.txt
- run: |
cd python
coverage run -m pytest -q
coverage html && coverage xml
- uses: actions/upload-artifact@v4
with: { name: coverage-py, path: python/htmlcov }
java:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v4
- uses: actions/setup-java@v4
with: { distribution: 'temurin', java-version: '21' }
- run: |
cd java
mvn -q -DskipTests=false test
- uses: actions/upload-artifact@v4
with: { name: coverage-java, path: java/target/site/jacoco }
9) Critérios de Avaliação (Rubrica — 100 pts)
● Design de testes (claridade, nomeação, AAA, independência) — 20 pts
● Cobertura (linhas ≥ 80% e branches ≥ 70% nas regras) — 15 pts
● TDD (commits e evidências do ciclo) — 15 pts
● Exceções e parametrizados — 10 pts
● Stubs & mocks corretos — 15 pts
● Integração simulada (fluxo completo) — 10 pts
● Performance (timeout) — 5 pts
● CI funcionando — 5 pts
● README/documentação — 5 pts
Bônus (até +5 pts): testes de contrato (p. ex., interface do
GatewayPagamento), teste de propriedades (valores aleatórios controlados),
ou mutação (PIT/Mutmut) com relatório.
Observação: Apesar de estar sendo pedida uma entrega do pacote, ela só
será considerada válida após a apresentação do Pitch.
10) Entrega
● Prazo sugerido: defina em aula (preencher data).
● Submeter link do repositório público (ou convidar avaliação).
● Inclua um screencast opcional (≤ 3 min) mostrando TDD e execução dos testes.
11) Orientações Pedagógicas (Aula 06 - B)
Integração com GitHub e o papel da CI/CD nos testes de software
O GitHub é parte essencial deste trabalho, atuando como repositório de código, ambiente
colaborativo e plataforma de integração contínua (CI). O uso do GitHub Actions
permite automatizar a execução dos testes e a geração de relatórios de cobertura sempre
que há novas alterações no código. Isso assegura:
● Reprodutibilidade: cada commit é testado automaticamente, garantindo
consistência.
● Transparência: resultados de testes e cobertura ficam acessíveis a todos os
colaboradores.
● Qualidade contínua: o pipeline de CI evita regressões e mantém o código estável.
● Histórico e rastreabilidade: todas as versões e correções de erros ficam
documentadas.
Importante: todos os alunos devem hospedar o projeto no GitHub e configurar
o pipeline conforme o modelo proposto. A execução local deve reproduzir os
mesmos resultados do CI.
Valores-Limite e BVA (Boundary Value Analysis)
A técnica de Análise de Valores-Limite (BVA) é usada para identificar erros em transições
críticas do domínio de entrada. Em vez de testar apenas valores típicos, o foco está nos
extremos válidos e inválidos. Exemplos:
● Para um campo que aceita de 1 a 10: testar 0, 1, 10 e 11.
● Para um triângulo: testar lados (1,1,2) e (1,2,3) que violam a desigualdade.
● Para desconto percentual (0–100%): testar -1, 0, 100, 101.
Esses casos são ideais para testes parametrizados, pois permitem cobrir várias
combinações rapidamente.
Apresentação (Pitch)
Além da entrega do código e documentação, cada grupo deverá realizar uma apresentação
curta (pitch) do trabalho:
● Duração: entre 5 e 10 minutos.
● Formato: livre — pode incluir slides, demonstração de código, terminal ou execução
de testes.
● Conteúdo esperado:
1. Explicação do cenário escolhido e das regras de negócio.
2. Demonstração dos testes parametrizados e tratamento de exceções.
3. Exibição do pipeline do GitHub Actions e dos relatórios de cobertura.
4. Destaques de desafios, aprendizados e melhorias futuras.
A apresentação deve enfatizar clareza, domínio técnico e síntese — comunicando o valor
do trabalho de forma objetiva, como em um pitch profissional.